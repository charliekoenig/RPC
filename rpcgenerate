#!/bin/env python3
import subprocess
import json
import sys
import os

# todo: ARRAYS

INDENT = 4
curr_indent_p = 0
indent_it_p = True
curr_indent_s = 0
indent_it_s = True

def print_indexed_array (indexed_array) -> str:
    ret_str = indexed_array.split("[")
    ret_str = '[\" << '.join(ret_str)
    ret_str = ret_str.split("]")
    ret_str = ' << \"]'.join(ret_str)

    return ret_str

def indent_it (indentation) -> str:
    return INDENT * indentation * " "

def IF (condition, iftrue, iffalse, indentation) -> str:
    ifBase = f"if ({condition}) {{" + "\n" + \
            indent_it(indentation + 1) +  f"{iftrue}" + "\n" + \
            indent_it(indentation) + "}"

    if iffalse is not None:
        ifBase = ifBase + " else " + iffalse
    
    return ifBase

def ELSE (body, indentation) -> str:
    return "{\n" + \
            indent_it(indentation + 1) + body + "\n" + \
            indent_it(indentation) + "}"

def BODY (body, indentation) -> str:
    i = indent_it(indentation)
    return ''.join(list(map(lambda line : i + line + "\n", body)))

def LOOP(type, condition, body, indentation) -> str:
    i = indent_it(indentation - 1)
    loop = f"{type} ({condition}) {{ \n{BODY(body, indentation)}" + i + "}"

    return loop

def deserialize_array(arg_name, arg_type, types, body, indentation):

    if types[arg_type]["type_of_type"] == "array":
        i = indentation + 1
        arg_name = arg_name + f"[i{i - 2}]"
        count = types[arg_type]["element_count"]
        next_arg_type = types[arg_type]["member_type"]

        b = deserialize_array(arg_name, next_arg_type, types, [], i)
        body.append(LOOP("for", f"int i{i - 2} = 0; i{i - 2} < {count}; i{i - 2}++", b, i))

        return body
    else:
        return deserialize(arg_name, arg_type, types, body, True, indentation)

def serialize_array(arg_name, arg_type, types, body, indentation, src):
    if types[arg_type]["type_of_type"] == "array":
        i = indentation + 1
        arg_name = arg_name + f"[i{i - 2}]"
        count = types[arg_type]["element_count"]
        next_arg_type = types[arg_type]["member_type"]

        b = serialize_array(arg_name, next_arg_type, types, [], i, src)
        body.append(LOOP("for", f"int i{i - 2} = 0; i{i - 2} < {count}; i{i - 2}++", b, i))

        return body
    else:
        return serialize(arg_name, arg_type, types, body, src, indentation)


def deserialize(arg_name, arg_type, types, body, array, indentation):

    writetype = "" if "." in arg_name or array else f"{arg_type} "
    log_style_arg = print_indexed_array(arg_name)
    if arg_type == "string":
        body.append(f"{writetype}{arg_name} = getStringFromStream();")
        body.append(f"*GRADING << \"Received value for {log_style_arg} of type string - message: \\\"\" << {arg_name} << \"\\\", length: \" << {arg_name}.length() + 1 << endl;\n\n")
    elif types[arg_type]["type_of_type"] == "builtin": 
        body.append(f"{writetype}{arg_name} = sto{arg_type[0]}(getStringFromStream());")
        body.append(f"*GRADING << \"Received value \" << {arg_name} << \" (of type {arg_type} in string form) for {log_style_arg}\" << endl;\n\n")
    elif types[arg_type]["type_of_type"] == "array":
        count = types[arg_type]["element_count"]

        if not array:
            body.append(f"{arg_type.split('__')[1].split('[')[0]} {arg_name}{arg_type[arg_type.index('['):]};")

        b = deserialize_array(arg_name, arg_type, types, [], indentation)
        body.append(BODY(b, 0))

    elif types[arg_type]["type_of_type"] == "struct":
        if "." not in arg_name and not array:
            body.append(f"{writetype}{arg_name};\n")

        for member in types[arg_type]["members"]:
            deserialize(f"{arg_name}.{member['name']}", member['type'], types, body, True, indentation)

    return body
            

def serialize(arg_name, arg_type, types, body, src, indentation):
    valid_var = arg_name.replace('.', "").replace('[', "").replace(']', "")
    log_style_arg = print_indexed_array(arg_name)
    if arg_type == "string":
        body.append(f"RPC{src}SOCKET->write({arg_name}.c_str(), {arg_name}.length() + 1);\n")
        body.append(f"*GRADING << \"Sending value of {log_style_arg} of type string - message: \\\"\" << {arg_name} << \"\\\", length: \" << {arg_name}.length() + 1 << endl;\n\n")
        
    elif types[arg_type]["type_of_type"] == "builtin": 
        body.append(f"string {valid_var}StringRep = to_string({arg_name});")
        body.append(f"*GRADING << \"Converting \" << {arg_name} << \" of type {arg_type} to string\" << endl;\n\n")
        body.append(f"RPC{src}SOCKET->write({valid_var}StringRep.c_str(), {valid_var}StringRep.length() + 1);")
        body.append(f"*GRADING << \"Sending value of {log_style_arg} in string form - message: \\\"\" << {arg_name} << \"\\\", length: \" << {valid_var}StringRep.length() + 1 << endl;\n\n")
        
    elif types[arg_type]["type_of_type"] == "array":
        b = serialize_array(arg_name, arg_type, types, [], indentation, src)
        body.append(BODY(b, 0))

    elif types[arg_type]["type_of_type"] == "struct":
        for member in types[arg_type]["members"]:
            serialize(f"{arg_name}.{member['name']}", member['type'], types, body, src, indentation)

    return body


def proxy_function_setup (name, sig, types) -> str:
    return_type = sig["return_type"]
    args        = sig["arguments"]

    argstring = ', '.join(a["type"] + ' ' + a["name"] if types[a["type"]]['type_of_type'] != "array"
                else f"{a['type'].split('__')[1].split('[')[0]} {a['name']}{a['type'][a['type'].index('['):]}" 
                for a in args)

    i = indent_it(1)

    return_str = f"{return_type} {name}({argstring}) {{\n"
    return_str += i + f"RPCPROXYSOCKET->write(\"{name}\", strlen(\"{name}\") + 1);\n"
    return_str += i + f"*GRADING << \"Invoking function {name} remotely - message: \\\"{name}\\\", length: \" << strlen(\"{name}\") + 1 << endl;\n\n"

    return return_str

def proxy_function_wrapup () -> str:
    i = indent_it(1)

    return_str = i + "char readBuffer[4];\n" + i + "RPCPROXYSOCKET->read(readBuffer, 4);\n"
    
    return_str += i + IF("strncmp(readBuffer, \"DONE\", 4) != 0", \
                       "throw C150Exception(\"error\");", \
                       None, 1)
    return_str += i + f"\n*GRADING << \"Returned successfully from RPC\"<< endl;\n\n"
                
    return return_str
    

def stub_function_setup (name, sig, types) -> str:
    return_type = sig["return_type"]
    args        = sig["arguments"]
    argstring = ', '.join([a["name"] for a in args])

    i = indent_it(1)

    return_str = f"void __{name}() {{\n"
    return_str += i + "char doneBuffer[5] = \"DONE\";\n\n"

    return return_str


def stub_function_wrapup () -> str:
    i = indent_it(1)

    return_str = i + "RPCSTUBSOCKET->write(doneBuffer, strlen(doneBuffer));"
    return_str += i + f"*GRADING << \"Function {name} invocation done\"<< endl;\n\n"

    return_str += i + "\n}\n\n"

    return return_str

def print_read_function(fd, sname):
    fd.write("string getStringFromStream() {\n")
    fd.write(BODY(["char bufp = '\\0';\n",
                   "vector<char> stringRead;\n",
                   "int readlen = 1;\n",
                   LOOP("while", "readlen == 1", 
                        [f"readlen = RPC{sname}SOCKET-> read(&bufp, 1);", 
                          "stringRead.push_back(bufp);",
                          IF("bufp == '\\0'", "break;", None, 2)], 2),
                   "return stringRead.data();\n"], 1))
    fd.write("}\n")

def print_line (fd, line, p_or_s):
    global curr_indent_p, indent_it_p, curr_indent_s, indent_it_s
    if ("}" in line) and ("{" in line):
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)
    elif ("{" in line):
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
            curr_indent_p += INDENT
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)
            curr_indent_s += INDENT
    elif ("}" in line):
        if p_or_s:
            curr_indent_p -= INDENT
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            curr_indent_s -= INDENT
            if indent_it_s: fd.write(" " * curr_indent_s)
    else:
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)

    if p_or_s:
        indent_it_p = "\n" in line
    else:
        indent_it_s = "\n" in line
    fd.write(line)

IDL_TO_JSON_EXECUTABLE = './idl_to_json'

try:
    # Make sure invoked properly
    assert len(sys.argv) == 2, "Wrong number of arguments"

    # Make sure IDL file exists and is readable
    filename = sys.argv[1]
    assert os.path.isfile(filename), f"Path {filename} does not designate a file"
    assert os.access(filename, os.R_OK), f"File {filename} is not readable"

    # Create the proxy and stub files for the IDL
    prog_name = filename[:-4]

    proxy = open(f"{prog_name}.proxy.cpp", "w")
    stub = open(f"{prog_name}.stub.cpp", "w")

    # Make sure idl_to_json exists and is executable
    assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
    assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

    # Parse declarations into a Python dictionary
    decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))

    # Set up the libraries and namespaces
    print_line(stub, "\n#include \"rpcstubhelper.h\"\n", False)
    print_line(stub, "\n#include <cstdio>", False)
    print_line(stub, "\n#include <cstring>\n", False)
    print_line(stub, "#include <vector>\n", False)
    print_line(stub, "#include <string>\n", False)
    print_line(stub, "using namespace std;\n", False)
    print_line(stub, f"#include \"{filename}\"\n", False)
    print_line(stub, "#include \"c150grading.h\"\n", False)
    print_line(stub, "\nusing namespace C150NETWORK;\n\n", False)
    print_line(stub, "string getStringFromStream();\n\n", False)

    print_line(proxy, "\n#include \"rpcproxyhelper.h\"\n", True)
    print_line(proxy, "\n#include <cstdio>", True)
    print_line(proxy, "\n#include <cstring>\n", True)
    print_line(proxy, "#include <string>\n", True)
    print_line(proxy, "\nusing namespace std;\n", True)
    print_line(proxy, f"#include \"{filename}\"\n", True)
    print_line(proxy, "#include \"c150grading.h\"\n", True)
    print_line(proxy, "using namespace C150NETWORK;\n\n", True)
    print_line(proxy, "string getStringFromStream();\n\n", True)

    # Loop printing each function signature
    types = decls["types"]
    for  name, sig in decls["functions"].items():
        proxy.write(proxy_function_setup(name, sig, types))
        stub.write(stub_function_setup(name, sig, types))

        for arg in sig["arguments"]:
            proxy.write(indent_it(1) + f"*GRADING << \"Serializing parameter {arg['name']}\"<< endl;\n\n")
            serialized = serialize(arg["name"], arg["type"], types, [], "PROXY", 1)
            deserialized = deserialize(arg["name"], arg["type"], types, [], False, 1)

            proxy.write(BODY(serialized, 1))
            stub.write(BODY(deserialized, 1))

        # handle returns
        # non void
        return_type = sig["return_type"]
        argstring = ', '.join([a["name"] for a in sig["arguments"]])

        stub.write(indent_it(1))
        stub.write(f"*GRADING << \"Function {name} invoked locally\"<< endl;\n")
        stub.write(indent_it(1))
        if return_type == "void":
            stub.write(f"{name}({argstring});\n")
        else: 
            stub.write(f"{return_type} retVal = {name}({argstring});\n")

            serialized = serialize("retVal", return_type, types, [], "STUB", 1)
            deserialized = deserialize("retVal", return_type, types, [], False, 1)

            proxy.write(BODY(deserialized, 1))
            stub.write(BODY(serialized, 1))

        # end of handling returns

        proxy.write(proxy_function_wrapup())
        stub.write(stub_function_wrapup())

        if return_type != "void":
            proxy.write("\n" + indent_it(1) + "return retVal;")

        proxy.write("\n}\n\n")

    print_line(stub, "void dispatchFunction() {\n", False)
    print_line(stub, "string functionName = getStringFromStream();\n\n", False)

    listFunctionNames = list(decls['functions'].items())
    if len(listFunctionNames) > 0:
        dispatchStr = IF(f"functionName == \"{listFunctionNames[0][0]}\"", f"__{listFunctionNames[0][0]}();", ELSE("RPCSTUBSOCKET->write(\"BAD\", strlen(\"BAD\") + 1);", 2), 2)
        tempDispatchStr = ""

    if len(listFunctionNames) > 1:
        for name, sig in listFunctionNames[1:]:
            tempDispatchStr = IF(f"functionName == \"{name}\"", f"__{name}();", dispatchStr, 2)
            dispatchStr = tempDispatchStr

    if len(listFunctionNames) > 0:
        stub.write(indent_it(1))
        stub.write(IF("!RPCSTUBSOCKET-> eof()", dispatchStr, None, 1))
    
    print_line(stub, "\n}\n\n", False)

    # if len(listFunctionNames) > 0:
    print_read_function(proxy, "PROXY")
    print_read_function(stub, "STUB")

    # Close the proxy and stub files for the IDL
    proxy.close()
    stub.close()

except Exception as e:
    print(str(e), file=sys.stderr)
    print(f"Usage: {sys.argv[0]} <idlfilename>", file=sys.stderr)