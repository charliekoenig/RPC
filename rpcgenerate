#!/bin/env python3
import subprocess
import json
import sys
import os

INDENT = 4
curr_indent_p = 0
indent_it_p = True
curr_indent_s = 0
indent_it_s = True

def indent_it (indentation) -> str:
    return INDENT * indentation * " "

def IF (condition, iftrue, iffalse, indentation) -> str:
    ifBase = f"if ({condition}) {{" + "\n" + \
            indent_it(indentation + 1) +  f"{iftrue}" + "\n" + \
            indent_it(indentation) + "}"

    if iffalse is not None:
        ifBase = ifBase + " else " + iffalse
    
    return ifBase

def ELSE (body, indentation) -> str:
    return "{\n" + \
            indent_it(indentation + 1) + body + "\n" + \
            indent_it(indentation) + "}"

def proxy_function (name, sig, types) -> str:
    return_type = sig["return_type"]
    args        = sig["arguments"]
    argstring = ', '.join([a["type"] + ' ' + a["name"] for a in args])

    i = indent_it(1)

    return_str = f"{return_type} {name}({argstring}) {{\n"
    return_str += i + f"int fNameLen = strlen(\"{name}\");\n"
    return_str += i + "RPCPROXYSOCKET->write((const char *) &fNameLen, sizeof(fNameLen));\n"
    return_str += i + f"RPCPROXYSOCKET->write(\"{name}\", strlen(\"{name}\"));\n\n"

    for j in range(0, len(args)):
        if types[args[j]['type']]["type_of_type"] == "builtin":
            return_str += i + f"RPCPROXYSOCKET->write((const char *) &{args[j]['name']}, sizeof({args[j]['name']}));\n\n"
        # for data to be serialized, go into else

    if (return_type != "void"):
        return_str += i + f"{return_type} retVal;\n"
        return_str += i + "RPCPROXYSOCKET->read((char *) &retVal, sizeof(retVal));\n\n"

    return_str += i + "char readBuffer[4];\n" + i + "RPCPROXYSOCKET->read(readBuffer, 4);\n"
    
    return_str += i + IF("strncmp(readBuffer, \"DONE\", 4) != 0", \
                       "throw C150Exception(\"error\");", \
                       None, 1)

    if (return_type != "void"):
        return_str += i + "return retVal;"
    
    return_str += "\n}\n\n"
                
    return return_str
    

def stub_function (name, sig, types) -> str:
    return_type = sig["return_type"]
    args        = sig["arguments"]
    argstring = ', '.join([a["name"] for a in args])

    i = indent_it(1)

    return_str = f"void __{name}() {{\n"
    return_str += i + "char doneBuffer[5] = \"DONE\";\n\n"

    for j in range(0, len(args)):
        if types[args[j]['type']]["type_of_type"] == "builtin":
            return_str += i + f"{args[j]['type']} {args[j]['name']};\n"
            return_str += i + f"RPCSTUBSOCKET->read((char *) &{args[j]['name']}, sizeof({args[j]['name']}));\n\n"
        # for data to be serialized, go into else

    if (return_type != "void"):
        return_str += i + f"{return_type} retVal = {name}("
    else:
        return_str += i + f"{name}("
    return_str += argstring + ");\n\n"
    
    if (return_type != "void"):
        if types[return_type]["type_of_type"] == "builtin":
            return_str += i + "RPCSTUBSOCKET->write((const char *) &retVal, sizeof(retVal));\n"

    return_str += i + "RPCSTUBSOCKET->write(doneBuffer, strlen(doneBuffer));"
    
    return_str += i + "\n}\n\n"

    return return_str


def print_line (fd, line, p_or_s):
    global curr_indent_p, indent_it_p, curr_indent_s, indent_it_s
    if ("}" in line) and ("{" in line):
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)
    elif ("{" in line):
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
            curr_indent_p += INDENT
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)
            curr_indent_s += INDENT
    elif ("}" in line):
        if p_or_s:
            curr_indent_p -= INDENT
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            curr_indent_s -= INDENT
            if indent_it_s: fd.write(" " * curr_indent_s)
    else:
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)

    if p_or_s:
        indent_it_p = "\n" in line
    else:
        indent_it_s = "\n" in line
    fd.write(line)

IDL_TO_JSON_EXECUTABLE = './idl_to_json'

try:
    # Make sure invoked properly
    assert len(sys.argv) == 2, "Wrong number of arguments"

    # Make sure IDL file exists and is readable
    filename = sys.argv[1]
    assert os.path.isfile(filename), f"Path {filename} does not designate a file"
    assert os.access(filename, os.R_OK), f"File {filename} is not readable"

    # Create the proxy and stub files for the IDL
    prog_name = filename[:-4]

    proxy = open(f"{prog_name}.proxy.cpp", "w")
    stub = open(f"{prog_name}.stub.cpp", "w")

    # Make sure idl_to_json exists and is executable
    assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
    assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

    # Parse declarations into a Python dictionary
    decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))

    # Set up the libraries and namespaces
    print_line(stub, f"#include \"{filename}\"\n", False)
    print_line(stub, "\n#include \"rpcstubhelper.h\"\n", False)
    print_line(stub, "\n#include <cstdio>", False)
    print_line(stub, "\n#include <cstring>\n", False)
    print_line(stub, "\nusing namespace C150NETWORK;\n\n", False)

    print_line(proxy, f"#include \"{filename}\"\n", True)
    print_line(proxy, "\n#include \"rpcproxyhelper.h\"\n", True)
    print_line(proxy, "\n#include <cstdio>", True)
    print_line(proxy, "\n#include <cstring>\n", True)
    print_line(proxy, "\nusing namespace C150NETWORK;\n\n", True)

    # Loop printing each function signature
    types = decls["types"]
    for  name, sig in decls["functions"].items():
        proxy.write(proxy_function(name, sig, types))
        stub.write(stub_function(name, sig, types))

    print_line(stub, "void dispatchFunction() {\n", False)
    print_line(stub, "int fNameLen;\n", False)
    print_line(stub, "RPCSTUBSOCKET->read((char *) &fNameLen, sizeof(fNameLen));\n\n", False)
    print_line(stub, "char functionNameBuffer[fNameLen + 1];\n\n", False)
    print_line(stub, "RPCSTUBSOCKET->read(functionNameBuffer, fNameLen);\n", False)
    print_line(stub, "functionNameBuffer[fNameLen] = '\\0';\n\n", False)

    listFunctionNames = list(decls['functions'].items())
    dispatchStr = IF(f"strcmp(functionNameBuffer, \"{listFunctionNames[0][0]}\") == 0", f"__{listFunctionNames[0][0]}();", ELSE("throw C150Exception(\"received above function name\\n\");", 2), 2)
    tempDispatchStr = ""

    for  name, sig in listFunctionNames[1:]:
        tempDispatchStr = IF(f"strcmp(functionNameBuffer, \"{name}\") == 0", f"__{name}();", dispatchStr, 2)
        dispatchStr = tempDispatchStr

    stub.write(indent_it(1))
    stub.write(IF("!RPCSTUBSOCKET-> eof()", dispatchStr, None, 1))
    print_line(stub, "\n}\n", False)

    # Close the proxy and stub files for the IDL
    proxy.close()
    stub.close()

except Exception as e:
    print(str(e), file=sys.stderr)
    print(f"Usage: {sys.argv[0]} <idlfilename>", file=sys.stderr)