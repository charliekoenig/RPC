#!/bin/env python3
import subprocess
import json
import sys
import os

INDENT = 4
curr_indent = 0

def print_line (fd, line):
    if (line.contains("{")):
        fd.write(" " * curr_indent)
        curr_indent += INDENT
    elif (line.contains("}")):
        curr_indent -= INDENT
        fd.write(" " * curr_indent)
    else:
        fd.write(" " * curr_indent)

    fd.write(line)

IDL_TO_JSON_EXECUTABLE = './idl_to_json'

try:
    # Make sure invoked properly
    assert len(sys.argv) == 2, "Wrong number of arguments"

    # Make sure IDL file exists and is readable
    filename = sys.argv[1]
    assert os.path.isfile(filename), f"Path {filename} does not designate a file"
    assert os.access(filename, os.R_OK), f"File {filename} is not readable"

    # Create the proxy and stub files for the IDL
    prog_name = filename[:-4]

    proxy = open(f"{prog_name}.proxy.cpp", "w")
    stub = open(f"{prog_name}.stub.cpp", "w")

    # Make sure idl_to_json exists and is executable
    assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
    assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

    # Parse declarations into a Python dictionary
    decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))

    indent = 0

    # Set up the libraries and namespaces
    stub.write(f"#include \"{filename}\"\n")
    stub.write("\n#include \"rpcstubhelper.h\"\n")
    stub.write("\n#include <cstdio>")
    stub.write("\n#include <cstring>\n")
    stub.write("\nusing namespace C150NETWORK;\n\n")

    proxy.write(f"#include \"{filename}\"\n")
    proxy.write("\n#include \"rpcproxyhelper.h\"\n")
    proxy.write("\n#include <cstdio>")
    proxy.write("\n#include <cstring>\n")
    proxy.write("\nusing namespace C150NETWORK;\n\n")

    # Loop printing each function signature
    for  name, sig in decls["functions"].items():

        # Python List of all args (each is a dictionary with keys "name" and "type")
        args = sig["arguments"]

        # Make a string of form:  "type1 arg1, type2 arg2" for use in function sig
        argstring = ', '.join([a["type"] + ' ' + a["name"] for a in args])

        # print the function signature
        proxy.write(f"{sig['return_type']} {name}({argstring}) {{\n")
        stub.write(f"void __{name}() {{\n")

        # fill in function defs in proxy
        proxy.write(f"    int fNameLen = strlen(\"{name}\");\n")
        proxy.write("    RPCPROXYSOCKET->write((const char *) &fNameLen, sizeof(fNameLen));\n")
        proxy.write(f"    RPCPROXYSOCKET->write(\"{name}\", strlen(\"{name}\"));\n\n")

        for i in range(0, len(args)):
            proxy.write(f"    RPCPROXYSOCKET->write((const char *) &{args[i]['name']}, sizeof({args[i]['name']}));\n\n")
        
        if (sig["return_type"] != "void"):
            proxy.write(f"    {args[i]['type']} retVal;\n")
            proxy.write("    RPCPROXYSOCKET->read((char *) &retVal, sizeof(retVal));\n\n")

        proxy.write("    char readBuffer[4];\n")
        proxy.write("    RPCPROXYSOCKET->read(readBuffer, 4);\n")
        proxy.write("    if (strncmp(readBuffer, \"DONE\", 4) != 0) { throw C150Exception(\"error\"); }")

        if (sig["return_type"] != "void"):
            proxy.write("\n\n    return retVal;")

        # fill in function defs in stub
        stub.write("    char doneBuffer[5] = \"DONE\";\n\n")

        for i in range(0, len(args)):
            stub.write(f"    {args[i]['type']} {args[i]['name']};\n")
            stub.write(f"    RPCSTUBSOCKET->read((char *) &{args[i]['name']}, sizeof({args[i]['name']}));\n\n")

        if (sig["return_type"] != "void"):
            stub.write(f"    {sig['return_type']} retVal = {name}(")
        else:
            stub.write(f"    {name}(")

        for i in range(0, len(args)):
            stub.write(f"{args[i]['name']}")
            if (i + 1 != len(args)):
                stub.write(", ")

        stub.write(");\n\n")

        if (sig["return_type"] != "void"):
            stub.write("    RPCSTUBSOCKET->write((const char *) &retVal, sizeof(retVal));\n")

        stub.write("    RPCSTUBSOCKET->write(doneBuffer, strlen(doneBuffer));")
        
        # end function definition
        proxy.write("\n}\n\n")
        stub.write("\n}\n\n")

    stub.write("void dispatchFunction() {\n")
    stub.write("    int fNameLen;\n")
    stub.write("    RPCSTUBSOCKET->read((char *) &fNameLen, sizeof(fNameLen));\n\n")
    stub.write("    char functionNameBuffer[fNameLen + 1];\n\n")
    stub.write("    RPCSTUBSOCKET->read(functionNameBuffer, fNameLen);\n")
    stub.write("    functionNameBuffer[fNameLen] = '\\0';\n\n")
    stub.write("    if (!RPCSTUBSOCKET-> eof()) {\n")
    
    for  name, sig in decls["functions"].items():
        stub.write(f"        if (strcmp(functionNameBuffer, \"{name}\") == 0) {{\n")
        stub.write(f"            __{name}();\n")
        stub.write("        } else ")

    stub.write("{\n")
    stub.write("            throw C150Exception(\"error\");\n")
    stub.write("        }\n")
    stub.write("    }\n}\n")


    # Close the proxy and stub files for the IDL
    proxy.close()
    stub.close()

except Exception as e:
    print(str(e), file=sys.stderr)
    print(f"Usage: {sys.argv[0]} <idlfilename>", file=sys.stderr)