#!/bin/env python3
import subprocess
import json
import sys
import os

# todo: ARRAYS

INDENT = 4
curr_indent_p = 0
indent_it_p = True
curr_indent_s = 0
indent_it_s = True

def indent_it (indentation) -> str:
    return INDENT * indentation * " "

def IF (condition, iftrue, iffalse, indentation) -> str:
    ifBase = f"if ({condition}) {{" + "\n" + \
            indent_it(indentation + 1) +  f"{iftrue}" + "\n" + \
            indent_it(indentation) + "}"

    if iffalse is not None:
        ifBase = ifBase + " else " + iffalse
    
    return ifBase

def ELSE (body, indentation) -> str:
    return "{\n" + \
            indent_it(indentation + 1) + body + "\n" + \
            indent_it(indentation) + "}"

def BODY (body, indentation) -> str:
    i = indent_it(indentation)
    return ''.join(list(map(lambda line : i + line + "\n", body)))

def LOOP(type, condition, body, indentation) -> str:
    i = indent_it(indentation - 1)
    loop = f"{type} ({condition}) {{ \n{BODY(body, indentation)}" + i + "}"

    return loop

def deserialize_array(arg_name, arg_type, types, body, indentation):

    if types[arg_type]["type_of_type"] == "array":
        i = indentation + 1
        arg_name = arg_name + f"[i{i - 2}]"
        count = types[arg_type]["element_count"]
        next_arg_type = types[arg_type]["member_type"]

        b = deserialize_array(arg_name, next_arg_type, types, [], i)
        body.append(LOOP("for", f"int i{i - 2} = 0; i{i - 2} < {count}; i++", b, i))

        return body
    else:
        return deserialize(arg_name, arg_type, types, body, True)

def serialize_array(arg_name, arg_type, types, body, indentation, src):

    if types[arg_type]["type_of_type"] == "array":
        i = indentation + 1
        arg_name = arg_name + f"[i{i - 2}]"
        count = types[arg_type]["element_count"]
        next_arg_type = types[arg_type]["member_type"]

        b = serialize_array(arg_name, next_arg_type, types, [], i, src)
        body.append(LOOP("for", f"int i{i - 2} = 0; i{i - 2} < {count}; i++", b, i))

        return body
    else:
        return serialize(arg_name, arg_type, types, body, src)


def deserialize(arg_name, arg_type, types, body, array):

    writetype = "" if "." in arg_name or array else f"{arg_type} "
    if arg_type == "string":
        body.append(f"{writetype}{arg_name} = getStringFromStream();")

    elif types[arg_type]["type_of_type"] == "builtin": 
        body.append(f"{writetype}{arg_name} = sto{arg_type[0]}(getStringFromStream());")

    elif types[arg_type]["type_of_type"] == "array":
        count = types[arg_type]["element_count"]

        body.append(f"{arg_type.split('__')[1].split('[')[0]} {arg_name}{arg_type[arg_type.index('['):]};")

        b = deserialize_array(arg_name, arg_type, types, [], 1)
        body.append(BODY(b, 0))
        return body


    elif types[arg_type]["type_of_type"] == "struct":
        if "." not in arg_name:
            body.append(f"{writetype}{arg_name};\n")

        for member in types[arg_type]["members"]:
            deserialize(f"{arg_name}.{member['name']}", member['type'], types, body, False)

    return body
            

def serialize(arg_name, arg_type, types, body, src):
    valid_var = arg_name.replace('.', "").replace('[', "").replace(']', "")
    if arg_type == "string":
        body.append(f"RPC{src}SOCKET->write({arg_name}.c_str(), {arg_name}.length() + 1);\n")
        
    elif types[arg_type]["type_of_type"] == "builtin": 
        body.append(f"string {valid_var}StringRep = to_string({arg_name});")
        body.append(f"RPC{src}SOCKET->write({valid_var}StringRep.c_str(), {valid_var}StringRep.length() + 1);")
        
    elif types[arg_type]["type_of_type"] == "array":
        b = serialize_array(arg_name, arg_type, types, [], 1, src)
        body.append(BODY(b, 0))
        return body
        # start forloop based on element count
            # recurse on member type
        # end forloop
    elif types[arg_type]["type_of_type"] == "struct":
        for member in types[arg_type]["members"]:
            serialize(f"{arg_name}.{member['name']}", member['type'], types, body, src)

    return body


def proxy_function_setup (name, sig, types) -> str:
    return_type = sig["return_type"]
    args        = sig["arguments"]

    argstring = ', '.join(a["type"] + ' ' + a["name"] if types[a["type"]]['type_of_type'] != "array"
                else f"{a['type'].split('__')[1].split('[')[0]} {a['name']}{a['type'][a['type'].index('['):]}" 
                for a in args)

    i = indent_it(1)

    return_str = f"{return_type} {name}({argstring}) {{\n"
    return_str += i + f"RPCPROXYSOCKET->write(\"{name}\", strlen(\"{name}\") + 1);\n\n"

    # for j in range(0, len(args)):
    #     if types[args[j]['type']]["type_of_type"] == "builtin":
    #         return_str += i + f"RPCPROXYSOCKET->write((const char *) &{args[j]['name']}, sizeof({args[j]['name']}));\n\n"
    #     # for data to be serialized, go into else

    # if (return_type != "void"):
    #     return_str += i + f"{return_type} retVal;\n"
    #     return_str += i + "RPCPROXYSOCKET->read((char *) &retVal, sizeof(retVal));\n\n"

    # return_str += i + "char readBuffer[4];\n" + i + "RPCPROXYSOCKET->read(readBuffer, 4);\n"
    
    # return_str += i + IF("strncmp(readBuffer, \"DONE\", 4) != 0", \
    #                    "throw C150Exception(\"error\");", \
    #                    None, 1)

    # if (return_type != "void"):
    #     return_str += i + "return retVal;"
    
    # return_str += "\n}\n\n"
                
    return return_str

def proxy_function_wrapup () -> str:
    i = indent_it(1)

    return_str = i + "char readBuffer[4];\n" + i + "RPCPROXYSOCKET->read(readBuffer, 4);\n"
    
    return_str += i + IF("strncmp(readBuffer, \"DONE\", 4) != 0", \
                       "throw C150Exception(\"error\");", \
                       None, 1)
                
    return return_str
    

def stub_function_setup (name, sig, types) -> str:
    return_type = sig["return_type"]
    args        = sig["arguments"]
    argstring = ', '.join([a["name"] for a in args])

    i = indent_it(1)

    return_str = f"void __{name}() {{\n"
    return_str += i + "char doneBuffer[5] = \"DONE\";\n\n"

    # for j in range(0, len(args)):
    #     if types[args[j]['type']]["type_of_type"] == "builtin":
    #         return_str += i + f"{args[j]['type']} {args[j]['name']};\n"
    #         return_str += i + f"RPCSTUBSOCKET->read((char *) &{args[j]['name']}, sizeof({args[j]['name']}));\n\n"
    #     # for data to be serialized, go into else

    # if (return_type != "void"):
    #     return_str += i + f"{return_type} retVal = {name}("
    # else:
    #     return_str += i + f"{name}("
    # return_str += argstring + ");\n\n"
    
    # if (return_type != "void"):
    #     if types[return_type]["type_of_type"] == "builtin":
    #         return_str += i + "RPCSTUBSOCKET->write((const char *) &retVal, sizeof(retVal));\n"

    # return_str += i + "RPCSTUBSOCKET->write(doneBuffer, strlen(doneBuffer));"
    
    # return_str += i + "\n}\n\n"

    return return_str


def stub_function_wrapup () -> str:
    i = indent_it(1)

    return_str = i + "RPCSTUBSOCKET->write(doneBuffer, strlen(doneBuffer));"
    
    return_str += i + "\n}\n\n"

    return return_str

def print_read_function(fd, sname):
    fd.write("string getStringFromStream() {\n")
    fd.write(BODY(["char bufp = '\\0';\n",
                   "vector<char> stringRead;\n",
                   "int readlen = 1;\n",
                   LOOP("while", "readlen == 1", 
                        [f"readlen = RPC{sname}SOCKET-> read(&bufp, 1);", 
                          "stringRead.push_back(bufp);",
                          IF("bufp == '\\0'", "break;", None, 2)], 2),
                   "return stringRead.data();\n"], 1))
    fd.write("}\n")

def print_line (fd, line, p_or_s):
    global curr_indent_p, indent_it_p, curr_indent_s, indent_it_s
    if ("}" in line) and ("{" in line):
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)
    elif ("{" in line):
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
            curr_indent_p += INDENT
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)
            curr_indent_s += INDENT
    elif ("}" in line):
        if p_or_s:
            curr_indent_p -= INDENT
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            curr_indent_s -= INDENT
            if indent_it_s: fd.write(" " * curr_indent_s)
    else:
        if p_or_s:
            if indent_it_p: fd.write(" " * curr_indent_p)
        else:
            if indent_it_s: fd.write(" " * curr_indent_s)

    if p_or_s:
        indent_it_p = "\n" in line
    else:
        indent_it_s = "\n" in line
    fd.write(line)

IDL_TO_JSON_EXECUTABLE = './idl_to_json'

try:
    # Make sure invoked properly
    assert len(sys.argv) == 2, "Wrong number of arguments"

    # Make sure IDL file exists and is readable
    filename = sys.argv[1]
    assert os.path.isfile(filename), f"Path {filename} does not designate a file"
    assert os.access(filename, os.R_OK), f"File {filename} is not readable"

    # Create the proxy and stub files for the IDL
    prog_name = filename[:-4]

    proxy = open(f"{prog_name}.proxy.cpp", "w")
    stub = open(f"{prog_name}.stub.cpp", "w")

    # Make sure idl_to_json exists and is executable
    assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
    assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

    # Parse declarations into a Python dictionary
    decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))

    # Set up the libraries and namespaces
    print_line(stub, f"#include \"{filename}\"\n", False)
    print_line(stub, "\n#include \"rpcstubhelper.h\"\n", False)
    print_line(stub, "\n#include <cstdio>", False)
    print_line(stub, "\n#include <cstring>\n", False)
    print_line(stub, "#include <vector>\n", False)
    print_line(stub, "\nusing namespace C150NETWORK;\n\n", False)
    print_line(stub, "string getStringFromStream();\n\n", False)

    print_line(proxy, f"#include \"{filename}\"\n", True)
    print_line(proxy, "\n#include \"rpcproxyhelper.h\"\n", True)
    print_line(proxy, "\n#include <cstdio>", True)
    print_line(proxy, "\n#include <cstring>\n", True)
    print_line(proxy, "\nusing namespace C150NETWORK;\n\n", True)
    print_line(proxy, "string getStringFromStream();\n\n", True)

    # Loop printing each function signature
    types = decls["types"]
    for  name, sig in decls["functions"].items():
        proxy.write(proxy_function_setup(name, sig, types))
        stub.write(stub_function_setup(name, sig, types))

        for arg in sig["arguments"]:
            serialized = serialize(arg["name"], arg["type"], types, [], "PROXY")
            deserialized = deserialize(arg["name"], arg["type"], types, [], False)

            proxy.write(BODY(serialized, 1))
            stub.write(BODY(deserialized, 1))

        # handle returns
        # non void
        return_type = sig["return_type"]
        argstring = ', '.join([a["name"] for a in sig["arguments"]])

        stub.write(indent_it(1))
        if return_type == "void":
            stub.write(f"{name}({argstring});\n")
        else: 
            stub.write(f"{return_type} retVal = {name}({argstring});\n")

            serialized = serialize("retVal", return_type, types, [], "STUB")
            deserialized = deserialize("retVal", return_type, types, [], False)

            proxy.write(BODY(deserialized, 1))
            stub.write(BODY(serialized, 1))

        # end of handling returns

        proxy.write(proxy_function_wrapup())
        stub.write(stub_function_wrapup())

        if return_type != "void":
            proxy.write("\n" + indent_it(1) + "return retVal;")

        proxy.write("\n}\n\n")

    print_line(stub, "void dispatchFunction() {\n", False)
    print_line(stub, "string functionName = getStringFromStream();\n\n", False)

    listFunctionNames = list(decls['functions'].items())
    if len(listFunctionNames) > 0:
        dispatchStr = IF(f"functionName == \"{listFunctionNames[0][0]}\"", f"__{listFunctionNames[0][0]}();", ELSE("throw C150Exception(\"received above function name\\n\");", 2), 2)
        tempDispatchStr = ""

    if len(listFunctionNames) > 1:
        for name, sig in listFunctionNames[1:]:
            tempDispatchStr = IF(f"functionName == \"{name}\"", f"__{name}();", dispatchStr, 2)
            dispatchStr = tempDispatchStr

    if len(listFunctionNames) > 0:
        stub.write(indent_it(1))
        stub.write(IF("!RPCSTUBSOCKET-> eof()", dispatchStr, None, 1))
    
    print_line(stub, "\n}\n\n", False)

    if len(listFunctionNames) > 0:
        print_read_function(proxy, "PROXY")
        print_read_function(stub, "STUB")

    # Close the proxy and stub files for the IDL
    proxy.close()
    stub.close()

except Exception as e:
    print(str(e), file=sys.stderr)
    print(f"Usage: {sys.argv[0]} <idlfilename>", file=sys.stderr)